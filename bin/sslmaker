#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/sslmaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SSLMAKER';
  package App::sslmaker;
  
  =head1 NAME
  
  App::sslmaker - Be your own SSL certificate authority
  
  =head1 VERSION
  
  0.01
  
  =head1 DESCRIPTION
  
  L<App::sslmaker> is a module that provide methods for acting as your own
  L<CA|http://en.wikipedia.org/wiki/Certificate_authority> (certificate authority).
  It can creating SSL keys, certificates and signing requests. The methods
  should have good defaults and "just work", so you don't have to worry about
  the details. "Just work" depends on safe defaults, which will change when
  new and more secure standards come along.
  
  The openssl commands are based on the instructions from
  L<https://jamielinux.com/blog/category/CA/>.
  
  This module is used by the C<sslmaker> command line application, but can also
  act as a standalone toolkit.
  
  From L<https://jamielinux.com/articles/2013/08/act-as-your-own-certificate-authority/>:
  
    Most websites, such as shopping, banking or email websites, need to let their
    customers know that the connection is secure. Thus, they need to pay a
    well-known and internationally trusted CA (eg, VeriSign) to issue an SSL
    certificate. However, this isn't always necessary. For example, if you're
    setting up a virtual private network (VPN) or an intranet website, it might
    make more sense to issue your own certificates.
  
    Being a CA means dealing with cryptographic pairs of private keys and public
    certificates. Ideally the cryptographic pairs should be generated in a secure
    environment, which means a personal laptop or computer that is disconnected
    from the Internet. It is not recommended to generate any certificates
    directly on your server.
  
  =head1 DISCLAIMER
  
  This module is based on tips and tricks from online resources, and has been
  reviewed by security experts. Even so, the L</AUTHOR> of this application or
  any parts involved cannot be held responsible for the security of your
  server, application or other parts that use the files generated by this
  library.
  
  =head1 COMMAND LINE USAGE
  
    $ sslmaker [options] {action} {arg1,...}
  
    # Generate root CA key and certificate
    $ sslmaker --home /path/to/pki/CA root
  
    # Generate intermediate CA key and certificate
    $ sslmaker --root-home /path/to/pki/CA --home /path/to/pki/intermediate intermediate
  
    # Generate client or server key and certificate signing request
    $ sslmaker --home /path/to/pki/intermediate generate <commonName>
    $ sslmaker --home /path/to/pki/intermediate generate www.example.com
    $ sslmaker --home /path/to/pki/intermediate nginx www.example.com
  
    # Sign a certificate signing request
    $ sslmaker --home /path/to/pki/intermediate sign www.example.com.csr.pem [outfile]
  
  =head1 SYNOPSIS
  
    my $sslmaker = App::sslmaker->new;
  
    my $asset = $sslmaker->make_csr({
                  key => "/path/to/private/input.key.pem",
                  passphrase => "/path/to/passphrase.txt",
                  subject => '/C=NO/ST=Oslo',
                });
  
    # the content of the csr
    print $asset->slurp;
  
    # move to a non-temp location
    $asset->move("/path/to/certs/output.csr.pem");
  
  All methods will throw an exception on error, unless otherwise noted.
  
  =cut
  
  use strict;
  use warnings;
  use Carp 'confess';
  use Path::Tiny;
  use File::umask;
  use constant DEBUG => $ENV{SSLMAKER_DEBUG} ? 1 : 0;
  use constant DEFAULT_BITS => 4096;
  use constant DEFAULT_DAYS => 365;
  
  our $VERSION = '0.01';
  our $OPENSSL = 'openssl';
  
  my @CONFIG_TEMPLATE_KEYS = qw( bits cert crl_days days home key );
  
  # heavily inspired by Mojo::Loader::_all()
  my %DATA = do {
    seek DATA, 0, 0;
    my $data = join '', <DATA>;
    $data =~ s/^.*\n__DATA__\r?\n/\n/s;
    $data =~ s/\n__END__\r?\n.*$/\n/s;
    $data = [split /^@@\s*(.+?)\s*\r?\n/m, $data];
    shift @$data; # first element is empty string
    @$data;
  };
  
  =head1 ATTRIBUTES
  
  =head2 subject
  
    $self = $self->subject('/C=NO/ST=Oslo/L=Oslo/O=Example/OU=Prime/emailAddress=admin@example.com');
    $str = $self->subject;
  
  Holds the default subject field for the certificates.
  
  =cut
  
  sub subject {
    return do { $_[0]->{subject} = $_[1]; $_[0] } if @_ == 2;
    $_[0]->{subject} ||= '/C=NO/ST=Oslo/L=Oslo/O=Example/OU=Prime/emailAddress=admin@example.com';
    return $_[0]->{subject};
  }
  
  =head1 METHODS
  
  =head2 make_cert
  
    $asset = $self->make_cert({
                key => "/path/to/private/input.key.pem",
                passphrase => "/path/to/passphrase.txt",
                days => $number_of_days, # default: 365
                subject => '/C=NO/ST=Oslo', # optional
              });
  
  This method will generate a SSL certificate using a C<key> generated by
  L</make_key>. C<passphrase> should match the argument given to L</make_key>.
  An optional C<subject> can be provided. The subject string will be merged with the
  L</subject> attribute. C<days> can be used to set how many days the certificate
  should be valid.
  
  The returned C<$asset> is a L<Path::Tiny> object which holds the generated certificate
  file. It is possible to specify the location of this object by passing on C<cert> to
  this method.
  
  =cut
  
  sub make_cert {
    my ($self, $args) = @_;
    my $asset = $args->{cert} ? Path::Tiny->new($args->{cert}) : Path::Tiny->tempfile;
  
    local $UMASK = 0222; # make files with mode 444
  
    $self->_openssl(
      qw( req -new -sha256 -x509 -extensions v3_ca ),
      -passin => $self->_passphrase($args->{passphrase}),
      -days => $args->{days} || DEFAULT_DAYS,
      -key => $args->{key} || '',
      -out => $asset->path,
      -subj => $self->_render_ssl_subject($args->{subject}),
    );
  
    return $asset;
  }
  
  =head2 make_csr
  
    $asset = $self->make_csr({
                key => "/path/to/private/input.key.pem",
                passphrase => "/path/to/passphrase.txt",
                subject => '/C=NO/ST=Oslo',
                days => $number_of_days, # default: 365
              });
  
  This method will generate a SSL certificate signing request using a C<key>
  generated by L</make_key>. C<passphrase> is only required if the C<key> was
  generated with a C<passphrase>.  An optional C<subject> can be provided.
  The subject string will be merged with the L</subject> attribute.
  
  The returned C<$asset> is a L<Path::Tiny> object which holds the generated
  signing request file. It is possible to specify the location of this object
  by passing on C<csr> to this method.
  
  =cut
  
  sub make_csr {
    my ($self, $args) = @_;
    my $asset = $args->{csr} ? Path::Tiny->new($args->{csr}) : Path::Tiny->tempfile;
  
    local $UMASK = 0277; # make files with mode 400
  
    $self->_openssl(
      qw( req -new -sha256 ),
      $args->{passphrase} ? (-passin => $self->_passphrase($args->{passphrase})) : (),
      -key => $args->{key},
      -days => $args->{days} || DEFAULT_DAYS,
      -out => $asset->path,
      -subj => $self->_render_ssl_subject($args->{subject}),
    );
  
    return $asset;
  }
  
  =head2 make_directories
  
    $self->make_directories({
      home => "/path/to/pki",
      templates => 1, # default: false
    });
  
  Used to generate a suitable file structure, which reflect what C<openssl.cnf>
  expects. Set C<$emplates> to a true value to generate L<files|/render_to_file>.
  
    $home/          # need to be writable by current user
    $home/certs/
    $home/crl/
    $home/newcerts/
    $home/private/  # will have mode 700
    # optional templates
    $home/index.txt
    $home/serial
  
  =cut
  
  sub make_directories {
    my ($self, $args) = @_;
    my $home = Path::Tiny->new($args->{home});
    my $file;
  
    $home->mkpath;
    -w $home or confess "Cannot write to $home";
    mkdir $home->child($_) for qw( certs crl newcerts private );
    chmod 0700, $home->child('private') or confess "Could not chmod 0700 'private' in $home";
  
    if ($args->{templates}) {
      local $UMASK = 0122; # make files with mode 644
      $self->render_to_file('index.txt', $file, {}) unless -e ($file = $home->child('index.txt'));
      $self->render_to_file('serial', $file, {}) unless -e ($file = $home->child('serial'));
    }
  
    return $args->{home}; # TBD, but will be true
  }
  
  =head2 make_key
  
    $asset = $self->make_key({
                passphrase => "/path/to/passphrase.txt", # optional
                bits => 8192, # default: 4096
              });
  
  This method will generate a SSL key.
  
  The key will be protected with C<passphrase> if given as input. In addition
  if C<passphrase> does not exist, it will be created with a random passphrase.
  
  The returned C<$asset> is a L<Path::Tiny> object which holds the generated key.
  It is possible to specify the location of this object by passing on C<key> to
  this method.
  
  From L<https://jamielinux.com/articles/2013/08/act-as-your-own-certificate-authority/>:
  
    The very first cryptographic pair we generate includes what is known as a
    root certificate. The root key (ca.key.pem) generated in this step should be
    kept extremely secure, otherwise an attacker can issue valid certificates for
    themselves. We'll therefore protect it with AES 256-bit encryption and a
    strong password just in case it falls into the wrong hands.
  
  =cut
  
  sub make_key {
    my ($self, $args) = @_;
    my $asset = $args->{key} ? Path::Tiny->new($args->{key}) : Path::Tiny->tempfile;
    my $passphrase;
  
    local $UMASK = 0277; # make files with mode 400
  
    if ($passphrase = $args->{passphrase}) {
      $passphrase = $self->_passphrase($passphrase);
      Path::Tiny->new($1)->spew({binmode => ':raw'}, $self->_random_passphrase(64)) if $passphrase =~ m!^file:(.+)! and !-e $1;
    }
  
    $self->_openssl(
      'genrsa',
      $passphrase ? (-aes256 => -passout => $passphrase) : (),
      -out => $asset->path,
      $args->{bits} || DEFAULT_BITS,
    );
  
    return $asset;
  }
  
  =head2 new
  
    $self = App::sslmaker->new(%args);
    $self = App::sslmaker->new(\%args);
  
  Object constructor.
  
  =cut
  
  # copy/paste from Mojo::Base::new()
  sub new {
    my $class = shift;
    bless @_ ? @_ > 1 ? {@_} : {%{$_[0]}} : {}, ref $class || $class;
  }
  
  =head2 render_to_file
  
    $asset = $self->render_to_file($template, \%stash);
    $asset = $self->render_to_file($template, $out_file, \%args);
  
  This method can render a C<$template> to either a temp file or C<$out_file>.
  The C<$template> will have access to C<%stash> and C<$self>.
  
  See L</TEMPLATES> for list of valid templates.
  
  =cut
  
  sub render_to_file {
    my $stash = pop;
    my ($self, $name, $path) = @_;
    my $template = $self->_render_template($name, $stash);
    my $asset;
  
    $asset = $path ? Path::Tiny->new($path) : Path::Tiny->tempfile;
    $asset->spew({binmode => ":raw"}, $template);
    $asset;
  }
  
  =head2 sign_csr
  
    $asset = $self->sign_csr({
                csr => "/path/to/certs/input.csr.pem",
                ca_key => "/path/to/private/ca.key.pem",
                ca_cert => "/path/to/certs/ca.cert.pem",
                passphrase => "/path/to/passphrase.txt",
                extensions => "v3_ca", # default: usr_cert
              });
  
  This method will sign a C<csr> file generated by L</make_csr>. C<ca_key> and
  C<passphrase> is the same values as you would provide L</make_key> and
  C<ca_cert> is the output from L</make_cert>.
  
  The returned C<$asset> is a L<Path::Tiny> object which holds the generated
  certificate. It is possible to specify the location of this object by
  passing on C<cert> to this method.
  
  =cut
  
  sub sign_csr {
    my ($self, $args) = @_;
    my $asset = $args->{cert} ? Path::Tiny->new($args->{cert}) : Path::Tiny->tempfile;
  
    local $UMASK = 0222; # make files with mode 444
  
    $self->_openssl(
      qw( ca -batch -notext -md sha256 ),
      -keyfile => $args->{ca_key},
      -cert => $args->{ca_cert},
      -passin => $self->_passphrase($args->{passphrase}),
      -extensions => $args->{extensions} || 'usr_cert',
      -out => $asset->path,
      -in => $args->{csr},
    );
  
    return $asset;
  }
  
  =head2 with_config
  
    $any = $self->with_config($method => \%args);
  
  Used to call a L<method|/METHODS> with a temp L</openssl.cnf>
  file. The C<%stash> in the template will be constructed from the C<%args>,
  which is also passed on to the next C<$method>. Example:
  
    $asset = $self->with_config(make_key => {
                home => "/path/to/pki",
                passphrase => "/path/to/pki/private/passphrase.txt",
                bits => 8192,
             });
  
  The config file will be removed when C<$self> go out of scope.
  
  An alternative to this method is to set the C<OPENSSL_CONF> environment
  variable before calling C<$method>:
  
    local $ENV{OPENSSL_CONF} = "/path/to/openssl.cnf";
    $asset = $self->make_key({...});
  
  =cut
  
  sub with_config {
    my ($self, $cb, $args) = @_;
    my $key = join ':', 'config', map { ($_, $args->{$_} // ''); } @CONFIG_TEMPLATE_KEYS;
  
    {
      local $UMASK = 0177; # read/write for current user
      $self->{$key} ||= $self->render_to_file('openssl.cnf', $args);
    }
  
    local $ENV{OPENSSL_CONF} = $self->{$key}->path;
    return $self->$cb($args);
  }
  
  sub _cat {
    my $self = shift;
    my $dest = pop;
  
    open my $DEST, '>', $dest or confess "Write $dest failed: $!";
    local @ARGV = @_;
    print $DEST $_ for <>;
    close $DEST or confess "Close $dest failed: $!";
    return $dest;
  }
  
  sub _openssl {
    my $cb = ref $_[-1] eq 'CODE' ? pop : sub { warn $_[1] if length $_[1] and DEBUG == 2 };
    my $self = shift;
    my $out = '';
  
    use IPC::Open3;
    use Symbol;
    warn "\$ $OPENSSL @_\n" if DEBUG;
    my $OUT = gensym;
    my $pid = open3(undef, $OUT, $OUT, $OPENSSL => @_);
    $out .= $_ while readline $OUT;
    waitpid $pid, 0;
    confess sprintf 'openssl %s FAIL (%s) (%s)', join(' ', @_), $? >> 8, $out if $?;
    $self->$cb($out);
  }
  
  sub _passphrase {
    my ($self, $phrase) = @_;
  
    confess "passphrase is required" unless defined $phrase and length $phrase;
    return confess "TODO" if ref $phrase eq 'SCALAR';
    return "file:$phrase";
  }
  
  sub _random_passphrase {
    my ($self, $length) = @_;
    my @chr = ('a'..'z', 'A'..'Z', 0..9);
    join '', map { $chr[rand @chr] } 1..$length;
  }
  
  sub _render_ssl_subject {
    my $self = shift;
    my $override = shift // '';
    my %subject = map { split '=', $_, 2 } split '/', $self->subject;
  
    for my $kv (split '/', $override) {
      $subject{$1} = $2 if $kv =~ /^([^=]+)=(.*)$/;
    }
  
    return join '/', '', map { "$_=$subject{$_}" } grep { defined $subject{$_} } qw( C ST L O OU CN emailAddress );
  }
  
  sub _render_template {
    my ($self, $name, $stash) = @_;
    my $template = $DATA{$name} // confess "No such template: $name";
    $template =~ s!<%=\s*([^%]+)\s*%>!{eval $1 // die $@}!ges; # super cheap template parser
    $template;
  }
  
  =head1 TEMPLATES
  
  L</render_to_file> can render these templates, which is bundled with this module:
  
  =over 4
  
  =item * index.txt
  
  This is currently just an empty file.
  
  =item * nginx.config
  
  Used to render an example nginx config. C<%stash> should contain C<cert>,
  C<client_certificate>, C<crl>, C<key>, C<server_name> and C<verify_client>.
  
  =item * openssl.cnf
  
  Creates a config file for openssl. TODO: Descrive stash values.
  
  =item * serial
  
  Creates a file which stores the SSL serial number. If C<n> is present in
  C<%stash>, it will be used as the start number, which defaults to 1000.
  
  =back
  
  =head1 COPYRIGHT AND LICENCE
  
  =head2 Code
  
  Copyright (C) 2014, Jan Henning Thorsen
  
  The code is free software, you can redistribute it and/or modify it under the
  terms of the Artistic License version 2.0.
  
  =head2 Documentation
  
  Documentation is licensed under the terms of Creative Commons
  Attribution-ShareAlike 3.0 Unported license.
  
  The documentation is put together by Jan Henning Thorsen, with citations from
  Jamie Nguyen's website L<https://jamielinux.com/>.
  
  =head1 AUTHOR
  
  Jan Henning Thorsen - C<jhthorsen@cpan.org>
  
  =cut
  
  1;
  __DATA__
  @@ index.txt
  @@ serial
  <%= $stash->{n} || 1000 %>
  @@ nginx.config
  server {
    listen 443;
    server_name <%= $stash->{domain} || 'example.com' %>;
  
    ssl on;
    ssl_certificate_key <%= $stash->{key} %>;
    ssl_certificate <%= $stash->{cert} %>;
    ssl_client_certificate <%= $stash->{ca_cert} %>;
    ssl_crl <%= $stash->{crl} || 'TODO' %>;
    ssl_verify_client <%= $stash->{verify_client} || 'optional' %>;
  
    location / {
      proxy_pass http://127.0.0.1:8080;
      proxy_set_header X-Forwarded-Proto "https";
      proxy_set_header X-SSL-Client-S-DN $ssl_client_s_dn; # /C=US/ST=Florida/L=Orlando/O=CLIENT NAME/CN=CLIENT NAME
      proxy_set_header X-SSL-Client-Verified $ssl_client_verify; # SUCCESS, FAILED, NONE
    }
  }
  @@ openssl.cnf
  HOME = <%= Path::Tiny->new($stash->{home})->absolute->stringify %>
  RANDFILE = $ENV::HOME/.rnd
  
  [ ca ]
  default_ca = CA_default
  
  [ CA_default ]
  dir = <%= Path::Tiny->new($stash->{home})->absolute->stringify %>
  certs = $dir/certs
  crl_dir = $dir/crl
  database = $dir/index.txt
  new_certs_dir = $dir/newcerts
  certificate = <%= $stash->{cert} || '$dir/certs/ca.cert.pem' %>
  serial = $dir/serial
  crlnumber = $dir/crlnumber
  crl = $dir/crl.pem
  private_key = <%= $stash->{key} || '$dir/private/ca.key.pem' %>
  RANDFILE = $dir/private/.rand
  x509_extensions = usr_cert
  name_opt = ca_default
  cert_opt = ca_default
  default_days = <%= $stash->{days} || DEFAULT_DAYS %>
  default_crl_days = <%= $stash->{crl_days} || 30 %>
  default_md = default
  preserve = no
  policy = policy_anything
  
  [ policy_anything ]
  countryName = optional
  stateOrProvinceName = optional
  localityName = optional
  organizationName = optional
  organizationalUnitName = optional
  commonName = supplied
  emailAddress = optional
  
  [ req ]
  default_bits = <%= $stash->{bits} || DEFAULT_BITS %>
  default_md = sha1
  default_keyfile = privkey.pem
  distinguished_name = req_distinguished_name
  attributes = req_attributes
  x509_extensions = v3_ca
  string_mask = utf8only
  
  [ req_distinguished_name ]
  
  [ req_attributes ]
  
  [ usr_cert ]
  basicConstraints=CA:FALSE
  keyUsage = nonRepudiation, digitalSignature, keyEncipherment
  nsComment = "OpenSSL Generated Certificate"
  subjectKeyIdentifier=hash
  authorityKeyIdentifier=keyid,issuer
  
  [ v3_ca ]
  subjectKeyIdentifier=hash
  authorityKeyIdentifier=keyid:always,issuer
  basicConstraints = CA:true
  keyUsage = cRLSign, keyCertSign
  
  [ crl_ext ]
  authorityKeyIdentifier=keyid:always
  
  [ proxy_cert_ext ]
  basicConstraints=CA:FALSE
  nsComment = "OpenSSL Generated Certificate"
  subjectKeyIdentifier=hash
  authorityKeyIdentifier=keyid,issuer
  proxyCertInfo=critical,language:id-ppl-anyLanguage,pathlen:3,policy:foo
APP_SSLMAKER

$fatpacked{"Applify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APPLIFY';
  package Applify;
  
  =head1 NAME
  
  Applify - Write object oriented scripts with ease
  
  =head1 VERSION
  
  0.07
  
  =head1 DESCRIPTION
  
  This module should keep all the noise away and let you write scripts
  very easily. These scripts can even be unittested even though they
  are define directly in the script file and not in a module.
  
  =head1 SYNOPSIS
  
    #!/usr/bin/perl
    use Applify;
  
    option file => input_file => 'File to read from';
    option dir => output_dir => 'Directory to write files to';
    option flag => dry_run => 'Use --no-dry-run to actually do something', 1;
  
    documentation __FILE__;
    version 1.23;
  
    sub generate_exit_value {
      return int rand 100;
    }
  
    app {
      my($self, @extra) = @_;
      my $exit_value = 0;
  
      print "Extra arguments: @extra\n" if(@extra);
      print "Will read from: ", $self->input_file, "\n";
      print "Will write files to: ", $self->output_dir, "\n";
  
      if($self->dry_run) {
        die 'Will not run script';
      }
  
      return $self->generate_exit_value;
    };
  
  =head1 APPLICATION CLASS
  
  This module will generate an application class, which C<$self> inside the
  L</app> block refere to. This class will have:
  
  =over 4
  
  =item * new()
  
  An object constructor. This method will not be auto generated if any of
  the classes given to L</extends> has the method C<new()>.
  
  =item * run()
  
  This method is basically the code block given to L</app>.
  
  =item * Other methods
  
  Other methods defined in the script file will be accesible from C<$self>
  inside C<app{}>.
  
  =item * _script()
  
  This is an accessor which return the L<Applify> object which
  is refered to as C<$self> in this documentation.
  
  NOTE: This accessor starts with an underscore to prevent conflicts
  with L</options>.
  
  =item * Other accessors
  
  Any L</option> (application switch) will be available as an accessor on the
  application object.
  
  =back
  
  =cut
  
  use strict;
  use warnings;
  use File::Basename ();
  
  use constant SUB_NAME_IS_AVAILABLE => $INC{'App/FatPacker/Trace.pm'}
    ? 0    # this will be true when running under "fatpack"
    : eval 'use Sub::Name; 1' ? 1 : 0;
  
  our $VERSION = '0.07';
  our $PERLDOC = 'perldoc';
  my $ANON = 1;
  
  sub __new_sub {
    my ($fqn, $code) = @_;
    no strict 'refs';
    return if *$fqn{CODE};
    *$fqn = SUB_NAME_IS_AVAILABLE ? Sub::Name::subname($fqn, $code) : $code;
  }
  
  =head1 EXPORTED FUNCTIONS
  
  =head2 option
  
      option $type => $name => $documentation;
      option $type => $name => $documentation, $default;
      option $type => $name => $documentation, $default, @args;
      option $type => $name => $documentation, @args;
  
  This function is used to define options which can be given to this
  application. See L</SYNOPSIS> for example code. This function can also be
  called as a method on C<$self>.
  
  =over 4
  
  =item * $type
  
  Used to define value types for this input.
  
  =over 4
  
  =item bool, flag
  
  =item inc
  
  =item str
  
  =item int
  
  =item num
  
  =item file (TODO)
  
  =item dir (TODO)
  
  =back
  
  =item * $name
  
  The name of an application switch. This name will also be used as
  accessor name inside the application. Example:
  
      # define an application switch:
      option file => some_file => '...';
  
      # call the application from command line:
      > myapp.pl --some-file /foo/bar
  
      # run the application code:
      app {
          my $self = shift;
          print $self->some_file # prints "/foo/bar"
          return 0;
      };
  
  =item * C<$documentation>
  
  Used as description text when printing the usage text.
  
  =item * C<@args>
  
  =over 4
  
  =item * C<required>
  
  The script will not start if a required field is omitted.
  
  =item * C<n_of>
  
  Allow the option to hold a list of values. Examples: "@", "4", "1,3".
  See L<Getopt::Long/Options-with-multiple-values> for details.
  
  =item * Other
  
  Any other L<Moose> attribute argument may/will be supported in
  future release.
  
  =back
  
  =back
  
  =cut
  
  sub option {
    my $self          = shift;
    my $type          = shift or die 'Usage: option $type => ...';
    my $name          = shift or die 'Usage: option $type => $name => ...';
    my $documentation = shift or die 'Usage: option $type => $name => $documentation, ...';
    my ($default, @args);
  
    if (@_ % 2) {
      $default = shift;
      @args    = @_;
    }
    else {
      @args = @_;
    }
  
    push @{$self->{options}},
      {default => $default, @args, type => $type, name => $name, documentation => $documentation,};
  
    return $self;
  }
  
  =head2 documentation
  
      documentation __FILE__; # current file
      documentation '/path/to/file';
      documentation 'Some::Module';
  
  Specifies where to retrieve documentaion from when giving the C<--man>
  switch to your script.
  
  =cut
  
  sub documentation {
    return $_[0]->{documentation} if @_ == 1;
    $_[0]->{documentation} = $_[1] or die 'Usage: documentation $file|$module_name;';
    return $_[0];
  }
  
  =head2 version
  
      version 'Some::Module';
      version $num;
  
  Specifies where to retrieve the version number from when giving the
  C<--version> switch to your script.
  
  =cut
  
  sub version {
    return $_[0]->{version} if @_ == 1;
    $_[0]->{version} = $_[1] or die 'Usage: version $module_name|$num;';
    return $_[0];
  }
  
  =head2 extends
  
      extends @classes;
  
  Specify which classes this application should inherit from. These
  classes can be L<Moose> based.
  
  =cut
  
  sub extends {
    my $self = shift;
    $self->{extends} = [@_];
    return $self;
  }
  
  =head2 app
  
      app CODE;
  
  This function will define the code block which is called when the application
  is started. See L</SYNOPSIS> for example code. This function can also be
  called as a method on C<$self>.
  
  IMPORTANT: This function must be the last function called in the script file
  for unittests to work. Reason for this is that this function runs the
  application in void context (started from command line), but returns the
  application object in list/scalar context (from L<perlfunc/do>).
  
  =cut
  
  sub app {
    my ($self, $code) = @_;
    my $parser = $self->_option_parser;
    my (%options, @options_spec, $application_class, $app);
  
    for my $option (@{$self->{options}}) {
      my $switch = $self->_attr_to_option($option->{name});
      push @options_spec, $self->_calculate_option_spec($option);
      $options{$switch} = $option->{default} if exists $option->{default};
    }
  
    unless ($parser->getoptions(\%options, @options_spec, $self->_default_options)) {
      $self->_exit(1);
    }
  
    if ($options{help}) {
      $self->print_help;
      $self->_exit('help');
    }
    elsif ($options{man}) {
      system $PERLDOC => $self->documentation;
      $self->_exit($? >> 8);
    }
    elsif ($options{version}) {
      $self->print_version;
      $self->_exit('version');
    }
  
    $application_class = $self->_generate_application_class($code);
    $app = $application_class->new({map { my $k = $self->_option_to_attr($_); $k => $options{$_} } keys %options});
  
    return $app if defined wantarray;    # $app = do $script_file;
    $self->_exit($app->run(@ARGV));
  }
  
  sub _calculate_option_spec {
    my ($self, $option) = @_;
    my $spec = $self->_attr_to_option($option->{name});
  
    if    ($option->{type} =~ /^(?:bool|flag)/i) { $spec .= '!' }
    elsif ($option->{type} =~ /^inc/)            { $spec .= '+' }
    elsif ($option->{type} =~ /^str/)            { $spec .= '=s' }
    elsif ($option->{type} =~ /^int/i)           { $spec .= '=i' }
    elsif ($option->{type} =~ /^num/i)           { $spec .= '=f' }
    elsif ($option->{type} =~ /^file/)           { $spec .= '=s' }    # TODO
    elsif ($option->{type} =~ /^dir/)            { $spec .= '=s' }    # TODO
    else                                         { die 'Usage: option {bool|flag|inc|str|int|num|file|dir} ...' }
  
    if (my $n_of = $option->{n_of}) {
      $spec .= $n_of eq '@' ? $n_of : "{$n_of}";
      $option->{default}
        and ref $option->{default} ne 'ARRAY'
        and die 'Usage option ... default => [Need to be an array ref]';
      $option->{default} ||= [];
    }
  
    return $spec;
  }
  
  sub _default_options {
    my $self = shift;
    my @default;
  
    push @default, 'help';
    push @default, 'man' if $self->documentation;
    push @default, 'version' if $self->version;
  
    return @default;
  }
  
  sub _generate_application_class {
    my ($self, $code) = @_;
    my $application_class = $self->{caller}[1];
    my $extends = $self->{extends} || [];
    my ($meta, @required);
  
    $application_class =~ s!\W!_!g;
    $application_class = join '::', ref($self), "__ANON__${ANON}__", $application_class;
    $ANON++;
  
    eval qq[
      package $application_class;
      use base qw/ @$extends /;
      1;
    ] or die "Failed to generate applicatin class: $@";
  
    {
      no strict 'refs';
      __new_sub "$application_class\::new" => sub { my $class = shift; bless shift, $class }
        unless grep { $_->can('new') } @$extends;
      __new_sub "$application_class\::_script" => sub {$self};
      __new_sub "$application_class\::run" => sub {
        my ($app, @extra) = @_;
  
        if (@required = grep { not defined $app->{$_} } @required) {
          my $required = join ', ', map { '--' . $self->_attr_to_option($_) } @required;
          $app->_script->print_help;
          die "Required attribute missing: $required\n";
        }
  
        return $app->$code(@extra);
      };
  
      for ('app', $self->{caller}[0]) {
        my $ns = \%{"$_\::"};
  
        for my $name (keys %$ns) {
          $self->{skip_subs}{$name} and next;
          my $code = eval { *{$ns->{$name}}{CODE} } or next;
          my $fqn = join '::', $application_class, $name;
          __new_sub $fqn => $code;
          delete $ns->{$name};    # may be a bit too destructive?
        }
      }
  
      $meta = $application_class->meta if $application_class->can('meta');
      $meta = undef unless UNIVERSAL::can($meta, 'add_attribute');
  
      for my $option (@{$self->{options}}) {
        my $name = $option->{name};
        my $fqn = join '::', $application_class, $option->{name};
        if ($meta) {
          $meta->add_attribute($name => {is => 'rw', default => $option->{default}});
        }
        else {
          __new_sub $fqn => sub { @_ == 2 and $_[0]->{$name} = $_[1]; $_[0]->{$name} };
        }
        push @required, $name if $option->{required};
      }
    }
  
    return $application_class;
  }
  
  =head1 ATTRIBUTES
  
  =head2 options
  
      $array_ref = $self->options;
  
  Holds the application options given to L</option>.
  
  =cut
  
  sub options { $_[0]->{options} }
  
  sub _option_parser {
    $_[0]->{_option_parser} ||= do {
      require Getopt::Long;
      Getopt::Long::Parser->new(config => [qw( no_auto_help no_auto_version pass_through )]);
    };
  }
  
  =head1 METHODS
  
  =head2 new
  
      $self = $class->new({ options => $array_ref, ... });
  
  Object constructor. Creates a new object representing the script meta
  information.
  
  =cut
  
  sub new {
    my ($class, $args) = @_;
    my $self = bless $args, $class;
  
    $self->{options} ||= [];
    $self->{caller} or die 'Usage: $self->new({ caller => [...], ... })';
  
    return $self;
  }
  
  =head2 print_help
  
  Will print L</options> to selected filehandle (STDOUT by default) in
  a normalized matter. Example:
  
      Usage:
         --foo      Foo does this and that
       * --bar      Bar does something else
  
         --help     Print this help text
         --man      Display manual for this application
         --version  Print application name and version
  
  =cut
  
  sub print_help {
    my $self    = shift;
    my @options = @{$self->{options}};
    my $width   = 0;
  
    push @options, {name => ''};
    push @options, {name => 'help', documentation => 'Print this help text'};
    push @options, {name => 'man', documentation => 'Display manual for this application'} if $self->documentation;
    push @options, {name => 'version', documentation => 'Print application name and version'} if $self->version;
    push @options, {name => ''};
  
    $self->_print_synopsis;
  
  OPTION:
    for my $option (@options) {
      my $length = length $option->{name};
      $width = $length if $width < $length;
    }
  
    print "Usage:\n";
  
  OPTION:
    for my $option (@options) {
      my $name = $self->_attr_to_option($option->{name}) or do { print "\n"; next OPTION };
  
      printf(" %s --%-${width}s  %s\n", $option->{required} ? '*' : ' ', $name, $option->{documentation},);
    }
  
    return $self;
  }
  
  sub _print_synopsis {
    my $self = shift;
    my $documentation = $self->documentation or return;
    my $print;
  
    unless (-e $documentation) {
      eval "use $documentation; 1" or die "Could not load $documentation: $@";
      $documentation =~ s!::!/!g;
      $documentation = $INC{"$documentation.pm"};
    }
  
    open my $FH, '<', $documentation or die "Failed to read synopsis from $documentation: $@";
  
    while (<$FH>) {
      last if $print and /^=(?:cut|head1)/;
      print if $print;
      $print = 1 if /^=head1 SYNOPSIS/;
    }
  }
  
  =head2 print_version
  
  Will print L</version> to selected filehandle (STDOUT by default) in
  a normalized matter. Example:
  
      some-script.pl version 1.23
  
  =cut
  
  sub print_version {
    my $self = shift;
    my $version = $self->version or die 'Cannot print version without version()';
  
    unless ($version =~ m!^\d!) {
      eval "require $version; 1" or die "Could not load $version: $@";
      $version = $version->VERSION;
    }
  
    printf "%s version %s\n", File::Basename::basename($0), $version;
  }
  
  sub _exit {
    my ($self, $reason) = @_;
    exit 0 unless ($reason =~ /^\d+$/);    # may change without warning...
    exit $reason;
  }
  
  sub _attr_to_option {
    local $_ = $_[1] or return;
    s!_!-!g;
    $_;
  }
  
  sub _option_to_attr {
    local $_ = $_[1] or return;
    s!-!_!g;
    $_;
  }
  
  =head2 import
  
  Will export the functions listed under L</EXPORTED FUNCTIONS>. The functions
  will act on a L<Applify> object created by this method.
  
  =cut
  
  sub import {
    my $class  = shift;
    my @caller = caller;
    my $self   = $class->new({caller => \@caller});
    my $ns     = $caller[0] . '::';
  
    strict->import;
    warnings->import;
  
    $self->{skip_subs} = {app => 1, option => 1, version => 1, documentation => 1, extends => 1,};
  
    no strict 'refs';
    for my $name (keys %$ns) {
      $self->{'skip_subs'}{$name} = 1;
    }
  
    no warnings 'redefine';    # need to allow redefine when loading a new app
    *{"$caller[0]\::app"}           = sub (&) { $self->app(@_) };
    *{"$caller[0]\::option"}        = sub     { $self->option(@_) };
    *{"$caller[0]\::version"}       = sub     { $self->version(@_) };
    *{"$caller[0]\::documentation"} = sub     { $self->documentation(@_) };
    *{"$caller[0]\::extends"}       = sub     { $self->extends(@_) };
  }
  
  =head1 COPYRIGHT & LICENSE
  
  This library is free software. You can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Jan Henning Thorsen
  
  =cut
  
  1;
APPLIFY

$fatpacked{"File/umask.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_UMASK';
  package File::umask;
  
  use 5.010001;
  use strict;
  use warnings;
  
  use POSIX qw();
  
  use Exporter qw(import);
  our @EXPORT = qw($UMASK);
  
  our $VERSION = '0.01'; # VERSION
  our $DATE = '2014-05-14'; # DATE
  
  our $UMASK; tie $UMASK, 'File::umask::SCALAR' or die "Can't tie \$UMASK";
  
  {
      package File::umask::SCALAR;
  
      sub TIESCALAR {
          bless [], $_[0];
      }
  
      sub FETCH {
          umask();
      }
  
      sub STORE {
          umask($_[1]);
      }
  }
  
  1;
  #ABSTRACT: Get/set umask via (localizeable) variable
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::umask - Get/set umask via (localizeable) variable
  
  =head1 VERSION
  
  This document describes version 0.01 of File::umask (from Perl distribution File-umask), released on 2014-05-14.
  
  =head1 SYNOPSIS
  
   use File::umask;
   printf "Current umask is %03o", $UMASK; # -> 022
   {
       local $UMASK = 0;
       open my($fh), ">", "/tmp/foo"; # file created with 666 permission mode
   }
   open my($fh), ">", "/tmp/two"; # file created with normal 644 permission mode
  
  =head1 DESCRIPTION
  
  This module is inspired by L<File::chdir>, using a tied scalar variable to
  get/set stuffs. One benefit of this is being able to use Perl's "local" with it,
  effectively setting something locally.
  
  =head1 EXPORTS
  
  =head2 $UMASK (exported by default)
  
  =head1 SEE ALSO
  
  Perl's umask builtin.
  
  L<Umask::Local>.
  
  Other modules with the same concept: L<File::chdir>, L<Locale::Tie>.
  
  =head1 HOMEPAGE
  
  Please visit the project's homepage at L<https://metacpan.org/release/File-umask>.
  
  =head1 SOURCE
  
  Source repository is at L<https://github.com/sharyanto/perl-File-umask>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=File-umask>
  
  When submitting a bug or request, please include a test-file or a
  patch to an existing test-file that illustrates the bug or desired
  feature.
  
  =head1 AUTHOR
  
  Steven Haryanto <stevenharyanto@gmail.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Steven Haryanto.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_UMASK

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Path::Tiny;
  # ABSTRACT: File path utility
  our $VERSION = '0.052'; # VERSION
  
  # Dependencies
  use Config;
  use Exporter 5.57   (qw/import/);
  use File::Spec 3.40 ();
  use Carp ();
  
  our @EXPORT    = qw/path/;
  our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;
  
  use constant {
      PATH     => 0,
      CANON    => 1,
      VOL      => 2,
      DIR      => 3,
      FILE     => 4,
      TEMP     => 5,
      IS_BSD   => ( scalar $^O =~ /bsd$/ ),
      IS_WIN32 => ( $^O eq 'MSWin32' ),
  };
  
  use overload (
      q{""}    => sub    { $_[0]->[PATH] },
      bool     => sub () { 1 },
      fallback => 1,
  );
  
  my $HAS_UU; # has Unicode::UTF8; lazily populated
  
  sub _check_UU {
      eval { require Unicode::UTF8; Unicode::UTF8->VERSION(0.58); 1 };
  }
  
  my $HAS_FLOCK = $Config{d_flock} || $Config{d_fcntl_can_lock} || $Config{d_lockf};
  
  # notions of "root" directories differ on Win32: \\server\dir\ or C:\ or \
  my $SLASH      = qr{[\\/]};
  my $NOTSLASH   = qr{[^\\/]};
  my $DRV_VOL    = qr{[a-z]:}i;
  my $UNC_VOL    = qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;
  my $WIN32_ROOT = qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;
  
  sub _win32_vol {
      my ( $path, $drv ) = @_;
      require Cwd;
      my $dcwd = eval { Cwd::getdcwd($drv) }; # C: -> C:\some\cwd
      # getdcwd on non-existent drive returns empty string
      # so just use the original drive Z: -> Z:
      $dcwd = "$drv" unless defined $dcwd && length $dcwd;
      # normalize dwcd to end with a slash: might be C:\some\cwd or D:\ or Z:
      $dcwd =~ s{$SLASH?$}{/};
      # make the path absolute with dcwd
      $path =~ s{^$DRV_VOL}{$dcwd};
      return $path;
  }
  
  # This is a string test for before we have the object; see is_rootdir for well-formed
  # object test
  sub _is_root {
      return IS_WIN32() ? ( $_[0] =~ /^$WIN32_ROOT$/ ) : ( $_[0] eq '/' );
  }
  
  # flock doesn't work on NFS on BSD.  Since program authors often can't control
  # or detect that, we warn once instead of being fatal if we can detect it and
  # people who need it strict can fatalize the 'flock' category
  
  #<<< No perltidy
  { package flock; use if Path::Tiny::IS_BSD(), 'warnings::register' }
  #>>>
  
  my $WARNED_BSD_NFS = 0;
  
  sub _throw {
      my ( $self, $function, $file ) = @_;
      if (   IS_BSD()
          && $function =~ /^flock/
          && $! =~ /operation not supported/i
          && !warnings::fatal_enabled('flock') )
      {
          if ( !$WARNED_BSD_NFS ) {
              warnings::warn( flock => "No flock for NFS on BSD: continuing in unsafe mode" );
              $WARNED_BSD_NFS++;
          }
      }
      else {
          Path::Tiny::Error->throw( $function, ( defined $file ? $file : $self->[PATH] ), $! );
      }
      return;
  }
  
  # cheapo option validation
  sub _get_args {
      my ( $raw, @valid ) = @_;
      if ( defined($raw) && ref($raw) ne 'HASH' ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak("Options for $called_as must be a hash reference");
      }
      my $cooked = {};
      for my $k (@valid) {
          $cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
      }
      if ( keys %$raw ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak( "Invalid option(s) for $called_as: " . join( ", ", keys %$raw ) );
      }
      return $cooked;
  }
  
  #--------------------------------------------------------------------------#
  # Constructors
  #--------------------------------------------------------------------------#
  
  
  sub path {
      my $path = shift;
      Carp::croak("path() requires a defined, positive-length argument")
        unless defined $path && length $path;
  
      # stringify initial path
      $path = "$path";
  
      # expand relative volume paths on windows; put trailing slash on UNC root
      if ( IS_WIN32() ) {
          $path = _win32_vol( $path, $1 ) if $path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};
          $path .= "/" if $path =~ m{^$UNC_VOL$};
      }
  
      # concatenate more arguments (stringifies any objects, too)
      if (@_) {
          $path .= ( _is_root($path) ? "" : "/" ) . join( "/", @_ );
      }
  
      # canonicalize paths
      my $cpath = $path = File::Spec->canonpath($path); # ugh, but probably worth it
      $path =~ tr[\\][/] if IS_WIN32();                 # unix convention enforced
      $path .= "/" if IS_WIN32() && $path =~ m{^$UNC_VOL$}; # canonpath strips it
  
      # hack to make splitpath give us a basename; root paths must always have
      # a trailing slash, but other paths must not
      if ( _is_root($path) ) {
          $path =~ s{/?$}{/};
      }
      else {
          $path =~ s{/$}{};
      }
  
      # do any tilde expansions
      if ( $path =~ m{^(~[^/]*).*} ) {
          my ($homedir) = glob($1); # glob without list context == heisenbug!
          $path =~ s{^(~[^/]*)}{$homedir};
      }
  
      # and we're finally done
      bless [ $path, $cpath ], __PACKAGE__;
  }
  
  
  sub new { shift; path(@_) }
  
  
  sub cwd {
      require Cwd;
      return path( Cwd::getcwd() );
  }
  
  
  sub rootdir { path( File::Spec->rootdir ) }
  
  
  sub tempfile {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
      # File::Temp->new demands TEMPLATE
      $args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;
  
      require File::Temp;
      my $temp = File::Temp->new( TMPDIR => 1, %$args );
      close $temp;
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  sub tempdir {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
  
      # File::Temp->newdir demands leading template
      require File::Temp;
      my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  # normalize the various ways File::Temp does templates
  sub _parse_file_temp_args {
      my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
      my %args = @_;
      %args = map { uc($_), $args{$_} } keys %args;
      my @template = (
            exists $args{TEMPLATE} ? delete $args{TEMPLATE}
          : $leading_template      ? $leading_template
          :                          ()
      );
      return ( \@template, \%args );
  }
  
  #--------------------------------------------------------------------------#
  # Private methods
  #--------------------------------------------------------------------------#
  
  sub _splitpath {
      my ($self) = @_;
      @{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
  }
  
  #--------------------------------------------------------------------------#
  # Public methods
  #--------------------------------------------------------------------------#
  
  
  sub absolute {
      my ( $self, $base ) = @_;
  
      # absolute paths handled differently by OS
      if (IS_WIN32) {
          return $self if length $self->volume;
          # add missing volume
          if ( $self->is_absolute ) {
              require Cwd;
              # use Win32::GetCwd not Cwd::getdcwd because we're sure
              # to have the former but not necessarily the latter
              my ($drv) = Win32::GetCwd() =~ /^($DRV_VOL | $UNC_VOL)/x;
              return path( $drv . $self->[PATH] );
          }
      }
      else {
          return $self if $self->is_absolute;
      }
  
      # relative path on any OS
      require Cwd;
      return path( ( defined($base) ? $base : Cwd::getcwd() ), $_[0]->[PATH] );
  }
  
  
  sub append {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, ">>", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw('close');
  }
  
  sub append_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &append }
  
  sub append_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          append( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &append;
      }
  }
  
  
  sub basename {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[FILE];
      return $self->[FILE];
  }
  
  
  sub canonpath { $_[0]->[CANON] }
  
  
  sub child {
      my ( $self, @parts ) = @_;
      return path( $self->[PATH], @parts );
  }
  
  
  sub children {
      my ( $self, $filter ) = @_;
      my $dh;
      opendir $dh, $self->[PATH] or $self->_throw('opendir');
      my @children = readdir $dh;
      closedir $dh or $self->_throw('closedir');
  
      if ( not defined $filter ) {
          @children = grep { $_ ne '.' && $_ ne '..' } @children;
      }
      elsif ( $filter && ref($filter) eq 'Regexp' ) {
          @children = grep { $_ ne '.' && $_ ne '..' && $_ =~ $filter } @children;
      }
      else {
          Carp::croak("Invalid argument '$filter' for children()");
      }
  
      return map { path( $self->[PATH], $_ ) } @children;
  }
  
  
  # XXX do recursively for directories?
  sub copy {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::copy( $self->[PATH], $dest )
        or Carp::croak("copy failed for $self to $dest: $!");
  }
  
  
  sub digest {
      my ( $self, $alg, @args ) = @_;
      $alg = 'SHA-256' unless defined $alg;
      require Digest;
      return Digest->new( $alg, @args )->add( $self->slurp_raw )->hexdigest;
  }
  
  
  sub dirname {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return length $self->[DIR] ? $self->[DIR] : ".";
  }
  
  
  sub exists { -e $_[0]->[PATH] }
  
  sub is_file { -f $_[0]->[PATH] }
  
  sub is_dir { -d $_[0]->[PATH] }
  
  
  # Note: must put binmode on open line, not subsequent binmode() call, so things
  # like ":unix" actually stop perlio/crlf from being added
  
  sub filehandle {
      my ( $self, @args ) = @_;
      my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
      $args = _get_args( $args, qw/locked/ );
      my ( $opentype, $binmode ) = @args;
  
      $opentype = "<" unless defined $opentype;
      Carp::croak("Invalid file mode '$opentype'")
        unless grep { $opentype eq $_ } qw/< +< > +> >> +>>/;
  
      $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $opentype, -1, 1 ) }
        unless defined $binmode;
      $binmode = "" unless defined $binmode;
  
      my ( $fh, $lock, $trunc );
      if ( $HAS_FLOCK && $args->{locked} ) {
          require Fcntl;
          # truncating file modes shouldn't truncate until lock acquired
          if ( grep { $opentype eq $_ } qw( > +> ) ) {
              # sysopen in write mode without truncation
              my $flags = $opentype eq ">" ? Fcntl::O_WRONLY() : Fcntl::O_RDWR();
              $flags |= Fcntl::O_CREAT();
              sysopen( $fh, $self->[PATH], $flags ) or $self->_throw("sysopen");
  
              # fix up the binmode since sysopen() can't specify layers like
              # open() and binmode() can't start with just :unix like open()
              if ( $binmode =~ s/^:unix// ) {
                  # eliminate pseudo-layers
                  binmode( $fh, ":raw" ) or $self->_throw("binmode (:raw)");
                  # strip off real layers until only :unix is left
                  while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
                      binmode( $fh, ":pop" ) or $self->_throw("binmode (:pop)");
                  }
              }
  
              # apply any remaining binmode layers
              if ( length $binmode ) {
                  binmode( $fh, $binmode ) or $self->_throw("binmode ($binmode)");
              }
  
              # ask for lock and truncation
              $lock  = Fcntl::LOCK_EX();
              $trunc = 1;
          }
          elsif ( $^O eq 'aix' && $opentype eq "<" ) {
              # AIX can only lock write handles, so upgrade to RW and LOCK_EX
              $opentype = "+<";
              $lock     = Fcntl::LOCK_EX();
          }
          else {
              $lock = $opentype eq "<" ? Fcntl::LOCK_SH() : Fcntl::LOCK_EX();
          }
      }
  
      unless ($fh) {
          my $mode = $opentype . $binmode;
          open $fh, $mode, $self->[PATH] or $self->_throw("open ($mode)");
      }
  
      do { flock( $fh, $lock ) or $self->_throw("flock ($lock)") } if $lock;
      do { truncate( $fh, 0 ) or $self->_throw("truncate") } if $trunc;
  
      return $fh;
  }
  
  
  sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }
  
  sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }
  
  
  sub is_rootdir {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return $self->[DIR] eq '/' && $self->[FILE] eq '';
  }
  
  
  sub iterator {
      my $self = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      my @dirs = $self;
      my $current;
      return sub {
          my $next;
          while (@dirs) {
              if ( ref $dirs[0] eq 'Path::Tiny' ) {
                  if ( !-r $dirs[0] ) {
                      # Directory is missing or not readable, so skip it.  There
                      # is still a race condition possible between the check and
                      # the opendir, but we can't easily differentiate between
                      # error cases that are OK to skip and those that we want
                      # to be exceptions, so we live with the race and let opendir
                      # be fatal.
                      shift @dirs and next;
                  }
                  $current = $dirs[0];
                  my $dh;
                  opendir( $dh, $current->[PATH] )
                    or $self->_throw( 'opendir', $current->[PATH] );
                  $dirs[0] = $dh;
                  if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
                      # Symlink attack! It was a real dir, but is now a symlink!
                      # N.B. we check *after* opendir so the attacker has to win
                      # two races: replace dir with symlink before opendir and
                      # replace symlink with dir before -l check above
                      shift @dirs and next;
                  }
              }
              while ( defined( $next = readdir $dirs[0] ) ) {
                  next if $next eq '.' || $next eq '..';
                  my $path = $current->child($next);
                  push @dirs, $path
                    if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
                  return $path;
              }
              shift @dirs;
          }
          return;
      };
  }
  
  
  sub lines {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode chomp count/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      my $chomp = $args->{chomp};
      # XXX more efficient to read @lines then chomp(@lines) vs map?
      if ( $args->{count} ) {
          my ( @result, $counter );
          while ( my $line = <$fh> ) {
              $line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if $chomp;
              push @result, $line;
              last if ++$counter == $args->{count};
          }
          return @result;
      }
      elsif ($chomp) {
          return map { s/(?:\x{0d}?\x{0a}|\x{0d})$//; $_ } <$fh>; ## no critic
      }
      else {
          return wantarray ? <$fh> : ( my $count =()= <$fh> );
      }
  }
  
  sub lines_raw {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if ( $args->{chomp} && !$args->{count} ) {
          return split /\n/, slurp_raw($self);                    ## no critic
      }
      else {
          $args->{binmode} = ":raw";
          return lines( $self, $args );
      }
  }
  
  sub lines_utf8 {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if (   ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() )
          && $args->{chomp}
          && !$args->{count} )
      {
          return split /(?:\x{0d}?\x{0a}|\x{0d})/, slurp_utf8($self); ## no critic
      }
      else {
          $args->{binmode} = ":raw:encoding(UTF-8)";
          return lines( $self, $args );
      }
  }
  
  
  sub mkpath {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err} = \$err unless defined $args->{err};
      require File::Path;
      my @dirs = File::Path::make_path( $self->[PATH], $args );
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("mkpath failed for $file: $message");
      }
      return @dirs;
  }
  
  
  sub move {
      my ( $self, $dst ) = @_;
  
      return rename( $self->[PATH], $dst )
        || $self->_throw( 'rename', $self->[PATH] . "' -> '$dst'" );
  }
  
  
  # map method names to corresponding open mode
  my %opens = (
      opena  => ">>",
      openr  => "<",
      openw  => ">",
      openrw => "+<"
  );
  
  while ( my ( $k, $v ) = each %opens ) {
      no strict 'refs';
      # must check for lexical IO mode hint
      *{$k} = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          my ($binmode) = @args;
          $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
            unless defined $binmode;
          $self->filehandle( $args, $v, $binmode );
      };
      *{ $k . "_raw" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw" );
      };
      *{ $k . "_utf8" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw:encoding(UTF-8)" );
      };
  }
  
  
  # XXX this is ugly and coverage is incomplete.  I think it's there for windows
  # so need to check coverage there and compare
  sub parent {
      my ( $self, $level ) = @_;
      $level = 1 unless defined $level && $level > 0;
      $self->_splitpath unless defined $self->[FILE];
      my $parent;
      if ( length $self->[FILE] ) {
          if ( $self->[FILE] eq '.' || $self->[FILE] eq ".." ) {
              $parent = path( $self->[PATH] . "/.." );
          }
          else {
              $parent = path( _non_empty( $self->[VOL] . $self->[DIR] ) );
          }
      }
      elsif ( length $self->[DIR] ) {
          # because of symlinks, any internal updir requires us to
          # just add more updirs at the end
          if ( $self->[DIR] =~ m{(?:^\.\./|/\.\./|/\.\.$)} ) {
              $parent = path( $self->[VOL] . $self->[DIR] . "/.." );
          }
          else {
              ( my $dir = $self->[DIR] ) =~ s{/[^\/]+/$}{/};
              $parent = path( $self->[VOL] . $dir );
          }
      }
      else {
          $parent = path( _non_empty( $self->[VOL] ) );
      }
      return $level == 1 ? $parent : $parent->parent( $level - 1 );
  }
  
  sub _non_empty {
      my ($string) = shift;
      return ( ( defined($string) && length($string) ) ? $string : "." );
  }
  
  
  sub realpath {
      my $self = shift;
      require Cwd;
      my $realpath = eval {
          local $SIG{__WARN__} = sub { }; # (sigh) pure-perl CWD can carp
          Cwd::realpath( $self->[PATH] );
      };
      $self->_throw("resolving realpath") unless defined $realpath and length $realpath;
      return path($realpath);
  }
  
  
  # Easy to get wrong, so wash it through File::Spec (sigh)
  sub relative { path( File::Spec->abs2rel( $_[0]->[PATH], $_[1] ) ) }
  
  
  sub remove {
      my $self = shift;
  
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
  
      return unlink $self->[PATH] || $self->_throw('unlink');
  }
  
  
  sub remove_tree {
      my ( $self, $args ) = @_;
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err}  = \$err unless defined $args->{err};
      $args->{safe} = 1     unless defined $args->{safe};
      require File::Path;
      my $count = File::Path::remove_tree( $self->[PATH], $args );
  
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("remove_tree failed for $file: $message");
      }
      return $count;
  }
  
  
  sub slurp {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
          and my $size = -s $fh )
      {
          my $buf;
          read $fh, $buf, $size; # File::Slurp in a nutshell
          return $buf;
      }
      else {
          local $/;
          return scalar <$fh>;
      }
  }
  
  sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }
  
  sub slurp_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
      }
      else {
          $_[1] = { binmode => ":raw:encoding(UTF-8)" };
          goto &slurp;
      }
  }
  
  
  # XXX add "unsafe" option to disable flocking and atomic?  Check benchmarks on append() first.
  sub spew {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $temp = path( $self->[PATH] . $$ . int( rand( 2**31 ) ) );
      my $fh = $temp->filehandle( { locked => 1 }, ">", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw( 'close', $temp->[PATH] );
  
      # spewing need to follow the link
      # and replace the destination instead
      my $resolved_path = $self->[PATH];
      $resolved_path = readlink $resolved_path while -l $resolved_path;
      return $temp->move($resolved_path);
  }
  
  sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }
  
  sub spew_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          spew( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &spew;
      }
  }
  
  
  # XXX break out individual stat() components as subs?
  sub stat {
      my $self = shift;
      require File::stat;
      return File::stat::stat( $self->[PATH] ) || $self->_throw('stat');
  }
  
  sub lstat {
      my $self = shift;
      require File::stat;
      return File::stat::lstat( $self->[PATH] ) || $self->_throw('lstat');
  }
  
  
  sub stringify { $_[0]->[PATH] }
  
  
  sub subsumes {
      my $self = shift;
      Carp::croak("subsumes() requires a defined, positive-length argument")
        unless defined $_[0];
      my $other = path(shift);
  
      # normalize absolute vs relative
      if ( $self->is_absolute && !$other->is_absolute ) {
          $other = $other->absolute;
      }
      elsif ( $other->is_absolute && !$self->is_absolute ) {
          $self = $self->absolute;
      }
  
      # normalize volume vs non-volume; do this after absolute path
      # adjustments above since that might add volumes already
      if ( length $self->volume && !length $other->volume ) {
          $other = $other->absolute;
      }
      elsif ( length $other->volume && !length $self->volume ) {
          $self = $self->absolute;
      }
  
      if ( $self->[PATH] eq '.' ) {
          return !!1; # cwd subsumes everything relative
      }
      elsif ( $self->is_rootdir ) {
          # a root directory ("/", "c:/") already ends with a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E};
      }
      else {
          # exact match or prefix breaking at a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E(?:/|$)};
      }
  }
  
  
  sub touch {
      my ( $self, $epoch ) = @_;
      if ( !-e $self->[PATH] ) {
          my $fh = $self->openw;
          close $fh or $self->_throw('close');
      }
      $epoch = defined($epoch) ? $epoch : time();
      utime $epoch, $epoch, $self->[PATH]
        or $self->_throw("utime ($epoch)");
      return $self;
  }
  
  
  sub touchpath {
      my ($self) = @_;
      my $parent = $self->parent;
      $parent->mkpath unless $parent->exists;
      $self->touch;
  }
  
  
  sub volume {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[VOL];
      return $self->[VOL];
  }
  
  package Path::Tiny::Error;
  
  our @CARP_NOT = qw/Path::Tiny/;
  
  use overload ( q{""} => sub { (shift)->{msg} }, fallback => 1 );
  
  sub throw {
      my ( $class, $op, $file, $err ) = @_;
      chomp( my $trace = Carp::shortmess );
      my $msg = "Error $op on '$file': $err$trace\n";
      die bless { op => $op, file => $file, err => $err, msg => $msg }, $class;
  }
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Path::Tiny - File path utility
  
  =head1 VERSION
  
  version 0.052
  
  =head1 SYNOPSIS
  
    use Path::Tiny;
  
    # creating Path::Tiny objects
  
    $dir = path("/tmp");
    $foo = path("foo.txt");
  
    $subdir = $dir->child("foo");
    $bar = $subdir->child("bar.txt");
  
    # stringifies as cleaned up path
  
    $file = path("./foo.txt");
    print $file; # "foo.txt"
  
    # reading files
  
    $guts = $file->slurp;
    $guts = $file->slurp_utf8;
  
    @lines = $file->lines;
    @lines = $file->lines_utf8;
  
    $head = $file->lines( {count => 1} );
  
    # writing files
  
    $bar->spew( @data );
    $bar->spew_utf8( @data );
  
    # reading directories
  
    for ( $dir->children ) { ... }
  
    $iter = $dir->iterator;
    while ( my $next = $iter->() ) { ... }
  
  =head1 DESCRIPTION
  
  This module attempts to provide a small, fast utility for working with
  file paths.  It is friendlier to use than L<File::Spec> and provides
  easy access to functions from several other core file handling modules.
  
  It doesn't attempt to be as full-featured as L<IO::All> or L<Path::Class>,
  nor does it try to work for anything except Unix-like and Win32 platforms.
  Even then, it might break if you try something particularly obscure or
  tortuous.  (Quick!  What does this mean: C<< ///../../..//./././a//b/.././c/././ >>?
  And how does it differ on Win32?)
  
  All paths are forced to have Unix-style forward slashes.  Stringifying
  the object gives you back the path (after some clean up).
  
  File input/output methods C<flock> handles before reading or writing,
  as appropriate (if supported by the platform).
  
  The C<*_utf8> methods (C<slurp_utf8>, C<lines_utf8>, etc.) operate in raw
  mode without CRLF translation.  Installing L<Unicode::UTF8> 0.58 or later
  will speed up several of them and is highly recommended.
  
  =head1 CONSTRUCTORS
  
  =head2 path
  
      $path = path("foo/bar");
      $path = path("/tmp", "file.txt"); # list
      $path = path(".");                # cwd
      $path = path("~user/file.txt");   # tilde processing
  
  Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  directory path.  It's still up to you to call directory-like methods only on
  directories and file-like methods only on files.  This function is exported
  automatically by default.
  
  The first argument must be defined and have non-zero length or an exception
  will be thrown.  This prevents subtle, dangerous errors with code like
  C<< path( maybe_undef() )->remove_tree >>.
  
  If the first component of the path is a tilde ('~') then the component will be
  replaced with the output of C<glob('~')>.  If the first component of the path
  is a tilde followed by a user name then the component will be replaced with
  output of C<glob('~username')>.  Behaviour for non-existent users depends on
  the output of C<glob> on the system.
  
  On Windows, if the path consists of a drive identifier without a path component
  (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  directory on that volume using C<Cwd::getdcwd()>.
  
  =head2 new
  
      $path = Path::Tiny->new("foo/bar");
  
  This is just like C<path>, but with method call overhead.  (Why would you
  do that?)
  
  =head2 cwd
  
      $path = Path::Tiny->cwd; # path( Cwd::getcwd )
      $path = cwd; # optional export
  
  Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  This is slightly faster than C<< path(".")->absolute >>.
  
  C<cwd> may be exported on request and used as a function instead of as a
  method.
  
  =head2 rootdir
  
      $path = Path::Tiny->rootdir; # /
      $path = rootdir;             # optional export 
  
  Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  picky for C<path("/")>.
  
  C<rootdir> may be exported on request and used as a function instead of as a
  method.
  
  =head2 tempfile, tempdir
  
      $temp = Path::Tiny->tempfile( @options );
      $temp = Path::Tiny->tempdir( @options );
      $temp = tempfile( @options ); # optional export
      $temp = tempdir( @options );  # optional export
  
  C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  object with the file name.  The C<TMPDIR> option is enabled by default.
  
  The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  destroyed, the C<File::Temp> object will be as well.
  
  C<File::Temp> annoyingly requires you to specify a custom template in slightly
  different ways depending on which function or method you call, but
  C<Path::Tiny> lets you ignore that and can take either a leading template or a
  C<TEMPLATE> option and does the right thing.
  
      $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
      $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  
  The tempfile path object will normalized to have an absolute path, even if
  created in a relative directory using C<DIR>.
  
  C<tempdir> is just like C<tempfile>, except it calls
  C<< File::Temp->newdir >> instead.
  
  Both C<tempfile> and C<tempdir> may be exported on request and used as
  functions instead of as methods.
  
  =head1 METHODS
  
  =head2 absolute
  
      $abs = path("foo/bar")->absolute;
      $abs = path("foo/bar")->absolute("/tmp");
  
  Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  absolute).  Unless an argument is given, the current directory is used as the
  absolute base path.  The argument must be absolute or you won't get an absolute
  result.
  
  This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  in L<File::Spec> would normally do so on your platform.  If you need them
  resolved, you must call the more expensive C<realpath> method instead.
  
  On Windows, an absolute path without a volume component will have it added
  based on the current drive.
  
  =head2 append, append_raw, append_utf8
  
      path("foo.txt")->append(@data);
      path("foo.txt")->append(\@data);
      path("foo.txt")->append({binmode => ":raw"}, @data);
      path("foo.txt")->append_raw(@data);
      path("foo.txt")->append_utf8(@data);
  
  Appends data to a file.  The file is locked with C<flock> prior to writing.  An
  optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to C<binmode()> on the handle used for writing.
  
  C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  unbuffered, raw write.
  
  C<append_utf8> is like C<append> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  append will be done instead on the data encoded with C<Unicode::UTF8>.
  
  =head2 basename
  
      $name = path("foo/bar.txt")->basename; # bar.txt
  
  Returns the file portion or last directory portion of a path.
  
  =head2 canonpath
  
      $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  
  Returns a string with the canonical format of the path name for
  the platform.  In particular, this means directory separators
  will be C<\> on Windows.
  
  =head2 child
  
      $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
      $file = path("/tmp")->child(@parts);
  
  Returns a new C<Path::Tiny> object relative to the original.  Works
  like C<catfile> or C<catdir> from File::Spec, but without caring about
  file or directories.
  
  =head2 children
  
      @paths = path("/tmp")->children;
      @paths = path("/tmp")->children( qr/\.txt$/ );
  
  Returns a list of C<Path::Tiny> objects for all files and directories
  within a directory.  Excludes "." and ".." automatically.
  
  If an optional C<qr//> argument is provided, it only returns objects for child
  names that match the given regular expression.  Only the base name is used
  for matching:
  
      @paths = path("/tmp")->children( qr/^foo/ );
      # matches children like the glob foo*
  
  =head2 copy
  
      path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  
  Copies a file using L<File::Copy>'s C<copy> function.
  
  =head2 digest
  
      $obj = path("/tmp/foo.txt")->digest;        # SHA-256
      $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
  
  Returns a hexadecimal digest for a file.  Any arguments are passed to the
  constructor for L<Digest> to select an algorithm.  If no arguments are given,
  the default is SHA-256.
  
  =head2 dirname
  
      $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  
  Returns the directory name portion of the path.  This is roughly
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually has the trailing slash. If that's not desired, stringify directories
  or call C<parent> on files.
  
  =head2 exists, is_file, is_dir
  
      if ( path("/tmp")->exists ) { ... }
      if ( path("/tmp")->is_file ) { ... }
      if ( path("/tmp")->is_dir ) { ... }
  
  Just like C<-e>, C<-f> or C<-d>.  This means the file or directory actually has to
  exist on the filesystem.  Until then, it's just a path.
  
  =head2 filehandle
  
      $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
  
  Returns an open file handle.  The C<$mode> argument must be a Perl-style
  read/write mode string ("<" ,">", "<<", etc.).  If a C<$binmode>
  is given, it is set during the C<open> call.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked with C<LOCK_SH>.  When using
  C<locked>, ">" or "+>" modes will delay truncation until after the lock is
  acquired.
  
  See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  
  =head2 is_absolute, is_relative
  
      if ( path("/tmp")->is_absolute ) { ... }
      if ( path("/tmp")->is_relative ) { ... }
  
  Booleans for whether the path appears absolute or relative.
  
  =head2 is_rootdir
  
      while ( ! $path->is_rootdir ) {
          $path = $path->parent;
          ...
      }
  
  Boolean for whether the path is the root directory of the volume.  I.e. the
  C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  
  This works even on C<MSWin32> with drives and UNC volumes:
  
      path("C:/")->is_rootdir;             # true
      path("//server/share/")->is_rootdir; #true
  
  =head2 iterator
  
      $iter = path("/tmp")->iterator( \%options );
  
  Returns a code reference that walks a directory lazily.  Each invocation
  returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  
      $iter = path("/tmp")->iterator;
      while ( $path = $iter->() ) {
          ...
      }
  
  The current and parent directory entries ("." and "..") will not
  be included.
  
  If the C<recurse> option is true, the iterator will walk the directory
  recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  directory links will be followed recursively.  There is no protection against
  loops when following links. If a directory is not readable, it will not be
  followed.
  
  The default is the same as:
  
      $iter = path("/tmp")->iterator( {
          recurse         => 0,
          follow_symlinks => 0,
      } );
  
  For a more powerful, recursive iterator with built-in loop avoidance, see
  L<Path::Iterator::Rule>.
  
  =head2 lines, lines_raw, lines_utf8
  
      @contents = path("/tmp/foo.txt")->lines;
      @contents = path("/tmp/foo.txt")->lines(\%options);
      @contents = path("/tmp/foo.txt")->lines_raw;
      @contents = path("/tmp/foo.txt")->lines_utf8;
  
      @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  
  Returns a list of lines from a file.  Optionally takes a hash-reference of
  options.  Valid options are C<binmode>, C<count> and C<chomp>.  If C<binmode>
  is provided, it will be set on the handle prior to reading.  If C<count> is
  provided, up to that many lines will be returned. If C<chomp> is set, any
  end-of-line character sequences (C<CR>, C<CRLF>, or C<LF>) will be removed
  from the lines returned.
  
  Because the return is a list, C<lines> in scalar context will return the number
  of lines (and throw away the data).
  
      $number_of_lines = path("/tmp/foo.txt")->lines;
  
  C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  instead of C<:unix> so PerlIO buffering can manage reading by line.
  
  C<lines_utf8> is like C<lines> with a C<binmode> of
  C<:raw:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  UTF-8 slurp will be done and then the lines will be split.  This is
  actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  intensive.  If memory use is a concern, consider C<openr_utf8> and
  iterating directly on the handle.
  
  =head2 mkpath
  
      path("foo/bar/baz")->mkpath;
      path("foo/bar/baz")->mkpath( \%options );
  
  Like calling C<make_path> from L<File::Path>.  An optional hash reference
  is passed through to C<make_path>.  Errors will be trapped and an exception
  thrown.  Returns the list of directories created or an empty list if
  the directories already exist, just like C<make_path>.
  
  =head2 move
  
      path("foo.txt")->move("bar.txt");
  
  Just like C<rename>.
  
  =head2 openr, openw, openrw, opena
  
      $fh = path("foo.txt")->openr($binmode);  # read
      $fh = path("foo.txt")->openr_raw;
      $fh = path("foo.txt")->openr_utf8;
  
      $fh = path("foo.txt")->openw($binmode);  # write
      $fh = path("foo.txt")->openw_raw;
      $fh = path("foo.txt")->openw_utf8;
  
      $fh = path("foo.txt")->opena($binmode);  # append
      $fh = path("foo.txt")->opena_raw;
      $fh = path("foo.txt")->opena_utf8;
  
      $fh = path("foo.txt")->openrw($binmode); # read/write
      $fh = path("foo.txt")->openrw_raw;
      $fh = path("foo.txt")->openrw_utf8;
  
  Returns a file handle opened in the specified mode.  The C<openr> style methods
  take a single C<binmode> argument.  All of the C<open*> methods have
  C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  C<:raw:encoding(UTF-8)>, respectively.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  
      $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  
  See L</filehandle> for more on locking.
  
  =head2 parent
  
      $parent = path("foo/bar/baz")->parent; # foo/bar
      $parent = path("foo/wibble.txt")->parent; # foo
  
      $parent = path("foo/bar/baz")->parent(2); # foo
  
  Returns a C<Path::Tiny> object corresponding to the parent directory of the
  original directory or file. An optional positive integer argument is the number
  of parent directories upwards to return.  C<parent> by itself is equivalent to
  C<parent(1)>.
  
  =head2 realpath
  
      $real = path("/baz/foo/../bar")->realpath;
      $real = path("foo/../bar")->realpath;
  
  Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  more expensive as it must actually consult the filesystem.
  
  If the path can't be resolved (e.g. if it includes directories that don't exist),
  an exception will be thrown:
  
      $real = path("doesnt_exist/foo")->realpath; # dies
  
  =head2 relative
  
      $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  
  Returns a C<Path::Tiny> object with a relative path name.
  Given the trickiness of this, it's a thin wrapper around
  C<< File::Spec->abs2rel() >>.
  
  =head2 remove
  
      path("foo.txt")->remove;
  
  B<Note: as of 0.012, remove only works on files>.
  
  This is just like C<unlink>, except if the path does not exist, it returns
  false rather than throwing an exception.
  
  =head2 remove_tree
  
      # directory
      path("foo/bar/baz")->remove_tree;
      path("foo/bar/baz")->remove_tree( \%options );
      path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  
  Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  An optional hash reference is passed through to C<remove_tree>.  Errors will be
  trapped and an exception thrown.  Returns the number of directories deleted,
  just like C<remove_tree>.
  
  If you want to remove a directory only if it is empty, use the built-in
  C<rmdir> function instead.
  
      rmdir path("foo/bar/baz/");
  
  =head2 slurp, slurp_raw, slurp_utf8
  
      $data = path("foo.txt")->slurp;
      $data = path("foo.txt")->slurp( {binmode => ":raw"} );
      $data = path("foo.txt")->slurp_raw;
      $data = path("foo.txt")->slurp_utf8;
  
  Reads file contents into a scalar.  Takes an optional hash reference may be
  used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for reading.
  
  C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  a fast, unbuffered, raw read.
  
  C<slurp_utf8> is like C<slurp> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  slurp will be done instead and the result decoded with C<Unicode::UTF8>.
  This is just as strict and is roughly an order of magnitude faster than
  using C<:encoding(UTF-8)>.
  
  =head2 spew, spew_raw, spew_utf8
  
      path("foo.txt")->spew(@data);
      path("foo.txt")->spew(\@data);
      path("foo.txt")->spew({binmode => ":raw"}, @data);
      path("foo.txt")->spew_raw(@data);
      path("foo.txt")->spew_utf8(@data);
  
  Writes data to a file atomically.  The file is written to a temporary file in
  the same directory, then renamed over the original.  An optional hash reference
  may be used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for writing.
  
  C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.
  
  C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>.
  If L<Unicode::UTF8> 0.58+ is installed, a raw spew will be done instead on
  the data encoded with C<Unicode::UTF8>.
  
  =head2 stat, lstat
  
      $stat = path("foo.txt")->stat;
      $stat = path("/some/symlink")->lstat;
  
  Like calling C<stat> or C<lstat> from L<File::stat>.
  
  =head2 stringify
  
      $path = path("foo.txt");
      say $path->stringify; # same as "$path"
  
  Returns a string representation of the path.  Unlike C<canonpath>, this method
  returns the path standardized with Unix-style C</> directory separators.
  
  =head2 subsumes
  
      path("foo/bar")->subsumes("foo/bar/baz"); # true
      path("/foo/bar")->subsumes("/foo/baz");   # false
  
  Returns true if the first path is a prefix of the second path at a directory
  boundary.
  
  This B<does not> resolve parent directory entries (C<..>) or symlinks:
  
      path("foo/bar")->subsumes("foo/bar/../baz"); # true
  
  If such things are important to you, ensure that both paths are resolved to
  the filesystem with C<realpath>:
  
      my $p1 = path("foo/bar")->realpath;
      my $p2 = path("foo/bar/../baz")->realpath;
      if ( $p1->subsumes($p2) ) { ... }
  
  =head2 touch
  
      path("foo.txt")->touch;
      path("foo.txt")->touch($epoch_secs);
  
  Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  changes the modification and access times to the current time.  If the first
  argument is the epoch seconds then it will be used.
  
  Returns the path object so it can be easily chained with spew:
  
      path("foo.txt")->touch->spew( $content );
  
  =head2 touchpath
  
      path("bar/baz/foo.txt")->touchpath;
  
  Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  before touching the file.  Returns the path object like C<touch> does.
  
  =head2 volume
  
      $vol = path("/tmp/foo.txt")->volume;   # ""
      $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  
  Returns the volume portion of the path.  This is equivalent
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually is the empty string on Unix-like operating systems or the
  drive letter for an absolute path on C<MSWin32>.
  
  =for Pod::Coverage openr_utf8 opena_utf8 openw_utf8 openrw_utf8
  openr_raw opena_raw openw_raw openrw_raw
  IS_BSD IS_WIN32
  
  =head1 EXCEPTION HANDLING
  
  Failures will be thrown as exceptions in the class C<Path::Tiny::Error>.
  
  The object will be a hash reference with the following fields:
  
  =over 4
  
  =item *
  
  C<op> — a description of the operation, usually function call and any extra info
  
  =item *
  
  C<file> — the file or directory relating to the error
  
  =item *
  
  C<err> — hold C<$!> at the time the error was thrown
  
  =item *
  
  C<msg> — a string combining the above data and a Carp-like short stack trace
  
  =back
  
  Exception objects will stringify as the C<msg> field.
  
  =head1 CAVEATS
  
  =head2 File locking
  
  If flock is not supported on a platform, it will not be used, even if
  locking is requested.
  
  See additional caveats below.
  
  =head3 NFS and BSD
  
  On BSD, Perl's flock implementation may not work to lock files on an
  NFS filesystem.  Path::Tiny has some heuristics to detect this
  and will warn once and let you continue in an unsafe mode.  If you
  want this failure to be fatal, you can fatalize the 'flock' warnings
  category:
  
      use warnings FATAL => 'flock';
  
  =head3 AIX and locking
  
  AIX requires a write handle for locking.  Therefore, calls that normally
  open a read handle and take a shared lock instead will open a read-write
  handle and take an exclusive lock.
  
  =head2 utf8 vs UTF-8
  
  All the C<*_utf8> methods use C<:encoding(UTF-8)> -- either as
  C<:unix:encoding(UTF-8)> (unbuffered) or C<:raw:encoding(UTF-8)> (buffered) --
  which is strict against the Unicode spec and disallows illegal Unicode
  codepoints or UTF-8 sequences.
  
  Unfortunately, C<:encoding(UTF-8)> is very, very slow.  If you install
  L<Unicode::UTF8> 0.58 or later, that module will be used by some C<*_utf8>
  methods to encode or decode data after a raw, binary input/output operation,
  which is much faster.
  
  If you need the performance and can accept the security risk,
  C<< slurp({binmode => ":unix:utf8"}) >> will be faster than C<:unix:encoding(UTF-8)>
  (but not as fast as C<Unicode::UTF8>).
  
  Note that the C<*_utf8> methods read in B<raw> mode.  There is no CRLF
  translation on Windows.  If you must have CRLF translation, use the regular
  input/output methods with an appropriate binmode:
  
    $path->spew_utf8($data);                            # raw
    $path->spew({binmode => ":encoding(UTF-8)"}, $data; # LF -> CRLF
  
  Consider L<PerlIO::utf8_strict> for a faster L<PerlIO> layer alternative to
  C<:encoding(UTF-8)>, though it does not appear to be as fast as the
  C<Unicode::UTF8> approach.
  
  =head2 Default IO layers and the open pragma
  
  If you have Perl 5.10 or later, file input/output methods (C<slurp>, C<spew>,
  etc.) and high-level handle opening methods ( C<filehandle>, C<openr>,
  C<openw>, etc. ) respect default encodings set by the C<-C> switch or lexical
  L<open> settings of the caller.  For UTF-8, this is almost certainly slower
  than using the dedicated C<_utf8> methods if you have L<Unicode::UTF8>.
  
  =head1 TYPE CONSTRAINTS AND COERCION
  
  A standard L<MooseX::Types> library is available at
  L<MooseX::Types::Path::Tiny>.  A L<Type::Tiny> equivalent is available as
  L<Types::Path::Tiny>.
  
  =head1 SEE ALSO
  
  These are other file/path utilities, which may offer a different feature
  set than C<Path::Tiny>.
  
  =over 4
  
  =item *
  
  L<File::Fu>
  
  =item *
  
  L<IO::All>
  
  =item *
  
  L<Path::Class>
  
  =back
  
  These iterators may be slightly faster than the recursive iterator in
  C<Path::Tiny>:
  
  =over 4
  
  =item *
  
  L<Path::Iterator::Rule>
  
  =item *
  
  L<File::Next>
  
  =back
  
  There are probably comparable, non-Tiny tools.  Let me know if you want me to
  add a module to the list.
  
  This module was featured in the L<2013 Perl Advent Calendar|http://www.perladvent.org/2013/2013-12-18.html>.
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Path-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Path-Tiny>
  
    git clone https://github.com/dagolden/Path-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Chris Williams <bingos@cpan.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Gabor Szabo <szabgab@cpan.org>
  
  =item *
  
  Gabriel Andrade <gabiruh@gmail.com>
  
  =item *
  
  George Hartzell <hartzell@cpan.org>
  
  =item *
  
  Geraud Continsouzas <geraud@scsi.nc>
  
  =item *
  
  Goro Fuji <gfuji@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Martin Kjeldsen <mk@bluepipe.dk>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =item *
  
  Toby Inkster <tobyink@cpan.org>
  
  =item *
  
  김도형 - Keedi Kim <keedi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
PATH_TINY

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

BEGIN { $ENV{SSLMAKER_DEBUG} //= 1; }
use Applify;
use App::sslmaker;
use Data::Dumper ();

option int => bits => 'SSL key bit size';
option int => days => 'Number of days the cert should be valid';
option str => home => 'Location of intermediate SSL files';
option str => root_home => 'Location of root SSL files';
option str => subject => 'Specify a SSL certificate subject string', $ENV{SSLMAKER_SUBJECT} || '';

documentation __FILE__;
version 'App::sslmaker';

my $wrapper = sub {
  my ($sslmaker, $method, @args) = @_;
  return $ENV{OPENSSL_CONF} ? $sslmaker->$method(@args) : $sslmaker->with_config($method, @args);
};

sub d {
  my $d = {@_};
  $_ and $_ = "$_" for values %$d;
  my $json = Data::Dumper->new([$d])->Indent(1)->Sortkeys(1)->Terse(1)->Useqq(1)->Dump;
  $json =~ s/" => /": /g; # ugly
  $json;
}

sub action_root {
  my ($self, @args) = @_;
  my $sslmaker = App::sslmaker->new(subject => $self->subject);
  my $home = $self->home ? Path::Tiny->new($self->home) : Path::Tiny->new('pki/CA')->absolute;
  my $args = {
    # key
    home => $home,
    bits => $self->bits || 8192,
    key => $home->child('private/ca.key.pem'),
    passphrase => $home->child('private/passphrase'),
    # cert
    cert => $home->child('certs/ca.cert.pem'),
    days => $self->days || 365 * 20,
  };

  print d %$args;
  $sslmaker->subject or die "--subject is required\n";
  $sslmaker->make_directories({ home => $home, templates => 1 });
  $self->run_maybe($args->{key}, sub { $sslmaker->$wrapper(make_key => $args) });
  $self->run_maybe($args->{cert}, sub { $sslmaker->$wrapper(make_cert => $args) });
  warn "Done.\n";
}

sub action_code {
  my $self = shift;

  for my $file ($0, $INC{'App/sslmaker.pm'}) {
    print "--- $file\n";
    local @ARGV = ($file);
    print for <>;
  }
}

sub action_generate {
  my $self = shift;
  my $cn = shift || die "Usage: $0 server <commonName>\n";
  my $sslmaker = App::sslmaker->new(subject => $self->subject);
  my $home = Path::Tiny->new($self->home || $ENV{SSLMAKER_HOME} || 'pki/intermediate')->absolute;
  my $args = {
    # key
    home => $home,
    bits => $self->bits || App::sslmaker::DEFAULT_BITS(),
    key => "$cn.key.pem",
    # csr
    csr => "$cn.csr.pem",
    days => $self->days || App::sslmaker::DEFAULT_DAYS(),
    subject => "/CN=$cn",
  };

  $self->run_maybe($args->{key}, sub { $sslmaker->make_key($args) });
  $self->run_maybe($args->{csr}, sub { $sslmaker->make_csr($args) });
  print "// Next: Need to send $args->{csr} to SSL admin for signing.\n";
  warn "Done.\n";
}

sub action_intermediate {
  my ($self, @args) = @_;
  my $sslmaker = App::sslmaker->new(subject => $self->subject);
  my $home = Path::Tiny->new($self->home || $ENV{SSLMAKER_HOME} || 'pki/intermediate')->absolute;
  my $root_home = $self->root_home ? Path::Tiny->new($self->root_home) : $home->parent->child('CA')->absolute;

  my $args = {
    # key
    home => $home,
    key => $home->child('private/intermediate.key.pem'),
    bits => $self->bits || App::sslmaker::DEFAULT_BITS(),
    passphrase => $home->child('private/passphrase'),
    # csr
    csr => $home->child('certs/intermediate.csr.pem'),
    days => $self->days || 365 * 10,
    # cert
    ca_cert => $root_home->child('certs/ca.cert.pem'),
    ca_key => $root_home->child('private/ca.key.pem'),
    cert => $home->child('certs/intermediate.cert.pem'),
    extensions => 'v3_ca',
  };

  print d %$args;
  $sslmaker->subject or die "--subject is required\n";
  $sslmaker->make_directories({ home => $home, templates => 1 });
  $self->run_maybe($args->{key}, sub { $sslmaker->$wrapper(make_key => $args) });
  $self->run_maybe($args->{csr}, sub { $sslmaker->$wrapper(make_csr => $args) });
  $args->{passphrase} = $root_home->child('private/passphrase');
  $self->run_maybe($args->{cert}, sub { $sslmaker->$wrapper(sign_csr => $args) });

  $args->{chain_cert} = $home->child('certs/ca-chain.cert.pem');
  $sslmaker->_cat(@$args{qw( cert root_cert chain_cert )});
  print "// Generated $args->{chain_cert} from CA and intermediate certificate\n";

  $sslmaker->_openssl(verify => -CAfile => @$args{qw( root_cert cert )}, sub {
    my ($sslmaker, $output) = @_;
    die $output if $output =~ /error/;
  });

  warn "Done.\n";
}

sub action_nginx {
  my $self = shift;
  my $domain = shift || die "Usage: $0 nginx <domain>\n";
  my $home = Path::Tiny->new($self->home || $ENV{SSLMAKER_HOME} || 'pki/intermediate')->absolute;

  print App::sslmaker->_render_template(
    'nginx.config',
    {
      domain => $domain,
      key => "/etc/nginx/ssl/$domain.key.pem",
      cert => "/etc/nginx/ssl/$domain.cert.pem",
      ca_cert => $home->child('certs/intermediate.cert.pem'),
    },
  );
}

sub action_pod {
  exec perldoc => 'App::sslmaker';
}

sub action_sign {
  my ($self, $csr, $cert) = @_;
  my $sslmaker = App::sslmaker->new(subject => $self->subject);
  my $home = Path::Tiny->new($self->home || $ENV{SSLMAKER_HOME} || 'pki/intermediate')->absolute;

  unless ($cert) {
    $cert = $csr;
    $cert =~ s!(\.csr)?\.pem$!\.cert.pem!;
  }

  $sslmaker->$wrapper(sign_csr => {
    home => $home,
    ca_cert => $home->child('certs/intermediate.cert.pem'),
    ca_key => $home->child('private/intermediate.key.pem'),
    cert => $cert,
    csr => $csr,
    extensions => 'usr_cert',
    passphrase => $home->child('private/passphrase'),
  });

  print "// Generated $cert\n";
  warn "Done.\n";
  warn "Run this command for more details: openssl x509 -in $cert -noout -text\n";
}

sub catch {
  my $self = shift;
  my $errno = $!;
  my $errstr = $@;

  # remove stacktrace
  $errstr =~ s!\sat\s\S+\sline.*!!s;

  # parse openssl exception
  if ($errstr =~ s!\sFAIL\s\((\d+)\)\s\((.*)\)$!!s) {
    $errno = $1;
    $errstr = $2;
  }

  $! = $errno;
  die $errstr;
}

sub run_maybe {
  my ($self, $file, $cb) = @_;

  if (-e $file) {
    print "// File $file exists.\n";
  }
  else {
    $self->$cb;
    print "// Generated $_[1]\n";
  }
}

app {
  my ($self, $action, @args) = @_;

  unless ($action and $self->can("action_$action")) {
    $self->_script->print_help;
    return 0;
  }

  eval {
    $self->can("action_$action")->($self, @args);
    1;
  } or $self->catch;

  return 0;
};

=head1 NAME

sslmaker - Generate SSL key, cert and csr

=head1 SYNOPSIS

  $ sslmaker [options] {action} {arg1,...}

  # Generate root CA key and certificate
  # https://jamielinux.com/articles/2013/08/act-as-your-own-certificate-authority/
  $ sslmaker --home /path/to/pki/CA root

  # Generate intermediate CA key and certificate
  # https://jamielinux.com/articles/2013/08/create-an-intermediate-certificate-authority/
  $ sslmaker --root-home /path/to/pki/CA --home /path/to/pki/intermediate intermediate

  # Generate client or server key and certificate signing request
  # https://jamielinux.com/articles/2013/08/create-and-sign-ssl-certificates-certificate-authority/
  $ sslmaker --home /path/to/pki/intermediate generate <commonName>
  $ sslmaker --home /path/to/pki/intermediate generate www.example.com
  $ sslmaker --home /path/to/pki/intermediate nginx www.example.com

  # Sign a certificate signing request
  $ sslmaker --home /path/to/pki/intermediate sign www.example.com.csr.pem [outfile]

  # Show the manual for App::sslmaker or the complete source code
  $ sslmaker pod
  $ sslmaker code | less

Set SSLMAKER_DEBUG=0 to avoid openssl output.
Set SSLMAKER_HOME=/etc/pki for default --home.
Set SSLMAKER_SUBJECT=/C=US for default --subject.

=head1 DISCLAIMER, COPYRIGHT AND LICENSE

See L<App::sslmaker>

=head1 AUTHOR

Jan Henning Thorsen - C<jhthorsen@cpan.org>

=cut
